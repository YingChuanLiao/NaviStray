function Astar(map,start,end){
    //new p5();// import random
    // remove the node if visited
    function removeFromArray(arr,element){
        for (var i = arr.length-1; i >= 0; i--){
            if (arr[i] === element){
                arr.splice(i,1);
            }
        }
    }
    // calculate the h value
    function heuristic (a,b){
        var d = dist(a.i,a.j, b.i,b.j);
        return d;
    }
    this.map = map;
    this.start = start;
    this.end = end;
    this.openSet = [];
    this.closedSet = [];
    this.openSet.push(start);
    this.lastCheckedNode = start;
    this.neighbors = [];
    this.step = function() {
        if (this.openSet.length >0){
            // find the lowest F in the openSet
            var lowestFidnex = 0;
            for(var i = 0; i < this.openSet.length; i++){
                if(this.openSet[i].f < this.openSet[lowestFidnex].f){
                    lowestFidnex = i; 
                }
            }
            var current = this.openSet[lowestFidnex];
            this.lastCheckedNode = current;
            // if reaching the goal
            if (current === end){
                //noLoop();
                console.log("done");
                return 1;

            }
            // put current node to the closeSet and remove from the openSet
            removeFromArray(this.openSet,current);
            this.closedSet.push(current);

            this.neighbors = current.addNeighbors();
            for (var i = 0; i < this.neighbors.length; i++){
                //check if neighbors are already in closeSet
                if (!this.closedSet.includes(this.neighbors[i])&& !this.neighbors[i].obstacle){ // not in 
                    var tempG = current.g + 1;
                    var newPath = false;
                    // check if neighbors are already in openSet
                    if (this.openSet.includes(this.neighbors[i])){ // in 
                        // that means the neighbor is already evaluated!
                        // spatial check
                        if (tempG < this.neighbors[i].g){
                            this.neighbors[i].g = tempG;
                            newPath = true;
                        }
                    }
                    // not in openSet
                    else{
                        this.openSet.push(this.neighbors[i]);
                        this.neighbors[i].g = tempG;
                        newPath = true;
                    }
                    if (newPath){
                        this.neighbors[i].h = heuristic(this.neighbors[i],end);
                        this.neighbors[i].f = this.neighbors[i].h + this.neighbors[i].g;
                        this.neighbors[i].parent = current;
                    }

                }
            }        
        }
        else{
            console.log('no solution');
            //noSol = true;
            //noLoop();// only draw once
            return -1;
        }
    }
}